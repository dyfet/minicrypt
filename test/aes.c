// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2025 David Sugar <tychosoft@gmail.com>

#undef  NDEBUG
#include <assert.h>
#include <string.h>
#include <stdio.h>

#include "../src/aes.h"

void print_value(const uint8_t *digest) {
    for (int i = 0; i < 16; ++i)
        printf("%02x", digest[i]);
    printf("\n");
}

void test_aes_ecb() {
    static const uint8_t key[16] = {
        0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
        0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c
    };

    static const uint8_t plaintext[16] = {
        0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
        0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a
    };

    static const uint8_t expected_ciphertext[16] = {
        0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60,
        0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97
    };

    uint8_t ciphertext[16] = {0};
    uint8_t decrypted[16] = {0};
    mc_aes_ctx ctx = {0};
    assert(mc_aes_setup(&ctx, (uint8_t *)key, MC_AES_128, NULL));

    mc_aes_encrypt(&ctx, plaintext, ciphertext);
    assert(!memcmp(ciphertext, expected_ciphertext, 16));

    mc_aes_decrypt(&ctx, ciphertext, decrypted);
    assert(!memcmp(plaintext, decrypted, 16));
}

void test_aes_cbc() {
    uint8_t key[16] = {
        0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
        0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c
    };

    uint8_t iv[16] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
    };

    uint8_t plaintext[32] = {
        0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
        0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
        0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
        0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51
    };

    uint8_t expected_ciphertext[32] = {
        0x76, 0x49, 0xab, 0xac, 0x81, 0x19, 0xb2, 0x46,
        0xce, 0xe9, 0x8e, 0x9b, 0x12, 0xe9, 0x19, 0x7d,
        0x50, 0x86, 0xcb, 0x9b, 0x50, 0x72, 0x19, 0xee,
        0x95, 0xdb, 0x11, 0x3a, 0x91, 0x76, 0x78, 0xb2
    };

    uint8_t ciphered[32], decrypted[32];
    mc_aes_ctx ctx;
    mc_aes_setup(&ctx, key, MC_AES_128, iv);
    mc_aes_encrypt_cbc(&ctx, plaintext, ciphered, 32);
    assert(memcmp(ciphered, expected_ciphertext, 32) == 0);

    mc_aes_setup(&ctx, key, MC_AES_128, iv);
    mc_aes_decrypt_cbc(&ctx, ciphered, decrypted, 32);
    assert(memcmp(decrypted, plaintext, 32) == 0);
}

void test_aes_ctr() {
    uint8_t key[16] = {
        0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
        0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c
    };

    uint8_t iv[16] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
    };

    uint8_t plaintext[32] = {
        0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
        0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
        0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
        0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51
    };

    uint8_t ciphered[32], decrypted[32];
    mc_aes_ctx ctx;

    // Encrypt
    mc_aes_setup(&ctx, key, MC_AES_128, iv);
    wc_aes_cipher_ctr(&ctx, plaintext, ciphered, 32);

    // Decrypt (same function, fresh context to reset counter)
    mc_aes_setup(&ctx, key, MC_AES_128, iv);
    wc_aes_cipher_ctr(&ctx, ciphered, decrypted, 32);

    // Validate round-trip
    assert(memcmp(decrypted, plaintext, 32) == 0);
}

int main() {
    test_aes_ecb();
    test_aes_cbc();
    test_aes_ctr();
    return 0;
}
